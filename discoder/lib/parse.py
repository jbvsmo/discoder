# coding: utf-8
""" Copyright (c) 2013 Jo√£o Bernardo Vianna Oliveira

    This file is part of Discoder.

    Discoder is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Discoder is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Discoder.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = 'jb'

from discoder.lib import Obj
import re

class ParseError(Exception):
    pass

tag = Obj(
    # Regex for parsing the markup language generated by ffprobe or avprobe
    open = re.compile(r'^\[(\w+)\]$'),
    close = re.compile(r'^\[/(\w+)\]$'),
    value = re.compile(r'^(\w+)(?::(\w+))?=(.*)$')
)

def probe(text):
    """
        Parse multiline text generated by `ffprobe` or `avprobe`
        Command line:
            ffprobe -v quiet [-show_format] [-show_streams] filename

        :type text: str
        
        Input:
        ------
        [TAG]
        data_x=1
        data_y=2
        INFO:data_z=3
        [/TAG]

        Output:
        -------
        {'tag': [{'data_x': 1, 'data_y': 2, 'info': {'data_z': 3}}]}
    """
    blocks = Obj()
    this = None
    for i, line in enumerate(text.splitlines()):
        if not line.strip():
            continue
        open_block = tag.open.match(line)
        if open_block:
            if this is not None:
                raise ParseError('Opened block without closing last one: {0}: {1}'.format(i, line))
            this = Obj()
            name = open_block.group(1).lower()
            if name == 'stream':
                name += 's' # compatibility with json output
            if name != 'format': # "format" only has one element.
                blocks.setdefault(name, []).append(this)
            else:
                blocks[name] = this
        else:
            if this is None:
                raise ParseError("There's no block to insert data or close: {0}: {1}".format(i, line))
            if tag.close.match(line):
                this = None
            else:
                name, sub, val = tag.value.match(line).groups()
                if not sub:
                    this[name] = val
                else:
                    attr = this.setdefault(name.lower(), Obj())
                    attr[sub] = val
    return blocks
